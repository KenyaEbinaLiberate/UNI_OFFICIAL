---
import { settings, calculateSlideSize } from '../utils/three/config';
import type { SlideInterface, ExtendedWindow } from '../utils/three/types';
import { vertexShader, fragmentShader } from '../utils/three/shaders';
import { animationTimings } from '../utils/animation-config';
---

<canvas id="canvas1" class="canvas-layer"></canvas>
<canvas id="canvas2" class="canvas-layer"></canvas>
<canvas id="canvas3" class="canvas-layer"></canvas>
<div class="img__name"></div>
<div class="img__filter"></div>
<div class="canvas__mask"></div>

<style>
  .canvas-layer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100dvh;
    opacity: 0;
    visibility: hidden;
    transition:
      opacity 1.5s ease-out,
      visibility 0s linear 0s;
    clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
  }

  .canvas-layer.visible {
    opacity: 1;
    visibility: visible;
  }

  @media (min-width: 768px) {
    .canvas-layer {
      width: 100vw;
      height: 100dvh;
    }
  }

  .canvas__mask {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: #eee;

    clip-path: inset(0 100% 0 0);
    transform-origin: left;
    pointer-events: none;
    z-index: 2;
  }

  .canvas__mask.active {
    animation: maskAnimation 0.7s cubic-bezier(0.7, 0, 0.3, 1) forwards;
  }

  @media (max-width: 767px) {
    .canvas__mask.active {
      animation-duration: 0.35s;
    }
  }

  @keyframes maskAnimation {
    0% {
      clip-path: inset(0 100% 0 0);
    }
    50% {
      clip-path: inset(0 0% 0 0);
    }
    100% {
      clip-path: inset(0 0 0 100%);
    }
  }

  .img__filter {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100dvh;
    background: rgba(0, 0, 255, 1);
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    mix-blend-mode: screen;
    transition: opacity 0.2s ease-out;
    backdrop-filter: brightness(1.2) contrast(2);
    z-index: 1;
  }

  .img__filter.visible {
    visibility: visible;
  }

  .img__name {
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease-out;
  }

  .img__name.visible {
    opacity: 1;
    visibility: visible;
  }
</style>

<script>
  import * as THREE from 'three';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
  import { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass.js';
  import { settings, calculateSlideSize } from '../utils/three/config';
  import { vertexShader, fragmentShader } from '../utils/three/shaders';
  import type { SlideInterface, ExtendedWindow } from '../utils/three/types';
  import { animationTimings } from '../utils/animation-config';

  declare const window: ExtendedWindow;

  // キャンバス要素の取得
  const canvases = {
    canvas1: document.getElementById('canvas1') as HTMLCanvasElement,
    canvas2: document.getElementById('canvas2') as HTMLCanvasElement,
    canvas3: document.getElementById('canvas3') as HTMLCanvasElement,
  };

  if (!canvases.canvas1 || !canvases.canvas2 || !canvases.canvas3) {
    throw new Error('Canvas elements not found');
  }

  const idleMessageElement = document.querySelector('.idle-message') as HTMLElement;
  const currentTimeElement = document.querySelector('.current-time') as HTMLElement;

  // アイドル状態の管理
  let idleTimer: ReturnType<typeof setTimeout> | null = null;
  let isIdle = false;
  const IDLE_TIMEOUT = 600000; // 10分

  // 各キャンバスのレンダラーを作成
  const renderers = {
    renderer1: new THREE.WebGLRenderer({
      canvas: canvases.canvas1,
      antialias: true,
      preserveDrawingBuffer: true,
    }),
    renderer2: new THREE.WebGLRenderer({
      canvas: canvases.canvas2,
      antialias: true,
      preserveDrawingBuffer: true,
    }),
    renderer3: new THREE.WebGLRenderer({
      canvas: canvases.canvas3,
      antialias: true,
      preserveDrawingBuffer: true,
    }),
  };

  // レンダラーの共通設定
  Object.values(renderers).forEach(renderer => {
    renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;
  });

  // シーンの作成
  const scenes = {
    scene1: new THREE.Scene(),
    scene2: new THREE.Scene(),
    scene3: new THREE.Scene(),
  };

  // シーンの背景色設定
  Object.values(scenes).forEach(scene => {
    scene.background = new THREE.Color(0x0000ff);
  });

  // カメラの作成
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.z = 5;

  // レスポンシブ対応の関数
  const updateRendererSize = () => {
    Object.values(renderers).forEach(renderer => {
      const canvas = renderer.domElement;
      const computedStyle = window.getComputedStyle(canvas);
      const width = parseInt(computedStyle.width);
      const height = parseInt(computedStyle.height);

      renderer.setSize(width, height, false);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    // カメラのアスペクト比を画面サイズに合わせる
    const canvas = canvases.canvas1;
    const computedStyle = window.getComputedStyle(canvas);
    const width = parseInt(computedStyle.width);
    const height = parseInt(computedStyle.height);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
  };

  // 初期設定
  updateRendererSize();

  // リサイズイベントの設定
  window.addEventListener('resize', () => {
    updateRendererSize();
    // スライドのサイズも更新
    slideSize = calculateSlideSize(camera);
    updateSlidesSize();
  });

  // フェードインアニメーション設定
  setTimeout(() => {
    canvases.canvas1.classList.add('visible');
    document.querySelector('.img__name')?.classList.add('visible');

    // 初期スライドインアニメーション
    targetPosition = -slideUnit * 6; // 半スライド分移動
    targetDistortionFactor = 1; // 適度な歪み効果
    const filter = document.querySelector('.img__filter') as HTMLElement;
    if (filter) {
      filter.classList.add('visible');
      filter.style.opacity = '0.5';
      setTimeout(() => {
        filter.style.opacity = '0';
        setTimeout(() => {
          filter.classList.remove('visible');
        }, 200);
      }, 1000);
    }
  }, animationTimings.threeScene.canvasFadeIn);

  let slideSize = calculateSlideSize(camera);
  const gap = 0;
  const slideCount = 8;
  const imagesCount = 24; // 全画像数を24に更新
  const totalWidth = slideCount * slideSize.width;
  const slideUnit = slideSize.width;

  // 各シーンのスライド配列
  const slidesGroups = {
    slides1: [] as SlideInterface[],
    slides2: [] as SlideInterface[],
    slides3: [] as SlideInterface[],
  };

  let currentPosition = 0;
  let targetPosition = 0;
  let isScrolling = false;
  let autoScrollSpeed = 0;
  let lastTime = 0;
  let touchStartX = 0;
  let touchLastX = 0;
  let prevPosition = 0;

  let currentDistortionFactor = 0;
  let targetDistortionFactor = 0;
  let peakVelocity = 0;
  let velocityHistory = [0, 0, 0, 0, 0];

  let isUserInteracting = false;
  let lastInteractionTime = 0;

  const correctImageColor = (texture: THREE.Texture): THREE.Texture => {
    texture.colorSpace = THREE.LinearSRGBColorSpace;
    return texture;
  };

  // 画像の読み込み
  const loadTexture = (index: number, material: THREE.ShaderMaterial) => {
    // 低解像度版を先に読み込む
    new THREE.TextureLoader().load(
      `/img${index}-low.webp`,
      lowResTexture => {
        lowResTexture.colorSpace = THREE.LinearSRGBColorSpace;
        material.uniforms.uTexture.value = lowResTexture;
        material.needsUpdate = true;

        // 高解像度版を後から読み込む
        new THREE.TextureLoader().load(
          `/img${index}.webp`,
          highResTexture => {
            highResTexture.colorSpace = THREE.LinearSRGBColorSpace;
            material.uniforms.uTexture.value = highResTexture;
            material.needsUpdate = true;

            if (highResTexture.image) {
              const imgAspect = highResTexture.image.width / highResTexture.image.height;
              const slideAspect = slideSize.width / slideSize.height;
              const viewportAspect = window.innerWidth / window.innerHeight;

              highResTexture.center.set(0.5, 0.5);

              // object-fit: coverのような動作を実現
              if (imgAspect > viewportAspect) {
                const scale = viewportAspect / imgAspect;
                highResTexture.repeat.set(scale, 1);
                highResTexture.offset.x = (1 - scale) / 2;
                highResTexture.offset.y = 0;
              } else {
                const scale = imgAspect / viewportAspect;
                highResTexture.repeat.set(1, scale);
                highResTexture.offset.y = (1 - scale) / 2;
                highResTexture.offset.x = 0;
              }

              highResTexture.wrapS = THREE.ClampToEdgeWrapping;
              highResTexture.wrapT = THREE.ClampToEdgeWrapping;
            }
          },
          undefined,
          error => console.warn('Error loading high-res texture:', error)
        );
      },
      undefined,
      error => console.warn('Error loading low-res texture:', error)
    );
  };

  // スライド作成関数を更新
  const createSlide = (index: number, groupIndex: number) => {
    const geometry = new THREE.PlaneGeometry(slideSize.width, slideSize.height, 32, 32);
    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        uTexture: { value: null },
        uTime: { value: 0 },
        uSpeed: { value: settings.liquidEffect.speed },
        uDistortionStrength: { value: 0.0 },
      },
      transparent: true,
    });

    const mesh = new THREE.Mesh(geometry, material) as SlideInterface;
    mesh.userData = {
      originalVertices: Array.from(geometry.attributes.position.array),
      targetX: index * (slideSize.width + gap),
      currentX: index * (slideSize.width + gap),
      index: index,
      currentImageIndex: index + 1 + (groupIndex - 1) * 8,
      nextTexture: null,
      isTransitioning: false,
      transitionProgress: 0,
      targetPosition: 0,
      currentPosition: 0,
      visible: true,
    };

    // 新しい画像読み込み関数を使用
    loadTexture(mesh.userData.currentImageIndex, material);

    // グループに応じてスライドを追加
    const targetSlides = slidesGroups[`slides${groupIndex}` as keyof typeof slidesGroups];
    targetSlides.push(mesh);
    scenes[`scene${groupIndex}` as keyof typeof scenes].add(mesh);
  };

  // 各グループのスライドを作成
  for (let groupIndex = 1; groupIndex <= 3; groupIndex++) {
    for (let i = 0; i < slideCount; i++) {
      createSlide(i, groupIndex);
    }
  }

  // キャンバス切り替えの管理
  let currentCanvasIndex = 1;
  const switchCanvas = () => {
    const currentCanvas = canvases[`canvas${currentCanvasIndex}` as keyof typeof canvases];
    const nextCanvasIndex = (currentCanvasIndex % 3) + 1;
    const nextCanvas = canvases[`canvas${nextCanvasIndex}` as keyof typeof canvases];
    const mask = document.querySelector('.canvas__mask') as HTMLElement;

    // マスクアニメーションを開始
    mask.classList.add('active');

    // アニメーション時間を画面サイズに応じて設定
    const duration = window.innerWidth >= 768 ? 700 : 350;
    const halfDuration = duration / 2;

    // マスクアニメーションの途中でキャンバスを切り替え
    setTimeout(() => {
      currentCanvas.style.opacity = '0';
      currentCanvas.style.visibility = 'hidden';
      nextCanvas.style.visibility = 'visible';
      nextCanvas.style.opacity = '1';
    }, halfDuration);

    // マスクアニメーション終了時にクラスを削除
    setTimeout(() => {
      mask.classList.remove('active');
    }, duration);

    currentCanvasIndex = nextCanvasIndex;
  };

  // 10秒ごとにキャンバスを切り替え
  setInterval(switchCanvas, 10000);

  // 自動スライド設定
  let autoSlideInterval: ReturnType<typeof setInterval> | null = null;
  const startAutoSlide = () => {
    if (autoSlideInterval) return;
    autoSlideInterval = setInterval(() => {
      if (!isUserInteracting) {
        targetPosition -= 0.0005; // 0.5を100倍遅く
        targetDistortionFactor = 0.01; // 歪み効果もさらに小さく
      }
    }, 16); // より頻繁な更新（約60FPS）
  };

  const stopAutoSlide = () => {
    if (autoSlideInterval) {
      clearInterval(autoSlideInterval);
      autoSlideInterval = null;
    }
  };

  // アニメーション関数を更新
  const animate = (time: number): void => {
    requestAnimationFrame(animate);

    const deltaTime = lastTime ? (time - lastTime) / 1000 : 0.016;
    lastTime = time;

    // 各グループのスライドを更新
    Object.entries(slidesGroups).forEach(([groupKey, slides]) => {
      const groupIndex = parseInt(groupKey.replace('slides', ''));
      const scene = scenes[`scene${groupIndex}` as keyof typeof scenes];
      const renderer = renderers[`renderer${groupIndex}` as keyof typeof renderers];

      slides.forEach(slide => {
        const targetX = slide.userData.targetX + currentPosition;
        slide.userData.currentX = THREE.MathUtils.lerp(
          slide.userData.currentX,
          targetX,
          0.05 // よりゆっくりな補間
        );
        slide.position.x = slide.userData.currentX;

        updateCurve(slide, slide.position.x, currentDistortionFactor);

        if (slide.position.x < -totalWidth / 2) {
          slide.position.x += totalWidth;
          slide.userData.targetX += totalWidth;
          slide.userData.currentX += totalWidth;
        } else if (slide.position.x > totalWidth / 2) {
          slide.position.x -= totalWidth;
          slide.userData.targetX -= totalWidth;
          slide.userData.currentX -= totalWidth;
        }

        const material = slide.material as THREE.ShaderMaterial;
        material.uniforms.uTime.value = time * 0.001;
        material.uniforms.uDistortionStrength.value = currentDistortionFactor;
      });

      renderer.render(scene, camera);
    });

    targetDistortionFactor *= settings.distortionDecay;
    currentDistortionFactor = THREE.MathUtils.lerp(
      currentDistortionFactor,
      targetDistortionFactor,
      settings.distortionSmoothing
    );

    currentPosition = THREE.MathUtils.lerp(currentPosition, targetPosition, 0.1);

    updateCenterImageIndex();
  };

  // スライドのサイズを更新する関数
  const updateSlidesSize = () => {
    const newSize = calculateSlideSize(camera);
    Object.values(slidesGroups).forEach(slides => {
      slides.forEach((slide, index) => {
        const newGeometry = new THREE.PlaneGeometry(newSize.width, newSize.height, 32, 32);
        slide.geometry.dispose();
        slide.geometry = newGeometry;
        slide.userData.originalVertices = Array.from(newGeometry.attributes.position.array);

        const newTotalWidth = slideCount * newSize.width;
        slide.position.x = index * newSize.width - newTotalWidth / 2 + currentPosition;
        slide.userData.targetX = slide.position.x - currentPosition;
        slide.userData.currentX = slide.position.x;

        const material = slide.material as THREE.ShaderMaterial;
        const texture = material.uniforms.uTexture.value as THREE.Texture;

        if (texture && texture.image) {
          const imgAspect = texture.image.width / texture.image.height;
          const slideAspect = newSize.width / newSize.height;
          const viewportAspect = window.innerWidth / window.innerHeight;

          texture.center.set(0.5, 0.5);

          // object-fit: coverのような動作を実現
          if (imgAspect > viewportAspect) {
            // 画像が画面より横長の場合、高さに合わせてスケーリング
            const scale = viewportAspect / imgAspect;
            texture.repeat.set(scale, 1);
            texture.offset.x = (1 - scale) / 2;
            texture.offset.y = 0;
          } else {
            // 画像が画面より縦長の場合、幅に合わせてスケーリング
            const scale = imgAspect / viewportAspect;
            texture.repeat.set(1, scale);
            texture.offset.y = (1 - scale) / 2;
            texture.offset.x = 0;
          }

          texture.wrapS = THREE.ClampToEdgeWrapping;
          texture.wrapT = THREE.ClampToEdgeWrapping;
        }
      });
    });
  };

  // カーブ更新関数
  const updateCurve = (
    mesh: SlideInterface,
    worldPositionX: number,
    distortionFactor: number
  ): void => {
    const positionAttribute = mesh.geometry.attributes.position;
    for (let i = 0; i < positionAttribute.count; i++) {
      positionAttribute.setZ(i, 0);
    }
    positionAttribute.needsUpdate = true;
    mesh.geometry.computeVertexNormals();
  };

  // イベントリスナーの更新
  const startUserInteraction = () => {
    isUserInteracting = true;
    lastInteractionTime = performance.now();
    stopAutoSlide();
  };

  const endUserInteraction = () => {
    isUserInteracting = false;
    startAutoSlide();
  };

  // イベントリスナーを追加
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') {
      targetPosition += slideUnit;
      targetDistortionFactor = Math.min(1.0, targetDistortionFactor + 1.6);
      const filter = document.querySelector('.img__filter') as HTMLElement;
      filter?.classList.add('visible');
      if (filter) filter.style.opacity = '0.5';
    } else if (e.key === 'ArrowRight') {
      targetPosition -= slideUnit;
      targetDistortionFactor = Math.min(1.0, targetDistortionFactor + 1.6);
      const filter = document.querySelector('.img__filter') as HTMLElement;
      filter?.classList.add('visible');
      if (filter) filter.style.opacity = '0.5';
    }
    startUserInteraction();
  });

  window.addEventListener(
    'wheel',
    e => {
      e.preventDefault();
      const wheelStrength = Math.abs(e.deltaY) * 1.1;
      targetDistortionFactor = Math.min(1.0, targetDistortionFactor + wheelStrength);
      targetPosition -= e.deltaY * settings.wheelSensitivity;

      // フィルター効果を追加
      const filter = document.querySelector('.img__filter') as HTMLElement;
      filter?.classList.add('visible');
      if (filter) filter.style.opacity = '0.5';

      startUserInteraction();

      if (window.scrollTimeout) {
        clearTimeout(window.scrollTimeout);
      }
      window.scrollTimeout = setTimeout(() => {
        endUserInteraction();
        // フィルター効果を徐々に消す
        const filter = document.querySelector('.img__filter') as HTMLElement;
        if (filter) {
          filter.style.opacity = '0';
          setTimeout(() => {
            filter.classList.remove('visible');
          }, 1200);
        }
      }, 1200);
    },
    { passive: false }
  );

  window.addEventListener(
    'touchstart',
    e => {
      touchStartX = e.touches[0].clientX;
      touchLastX = touchStartX;
      startUserInteraction();
    },
    { passive: false }
  );

  window.addEventListener(
    'touchmove',
    e => {
      e.preventDefault();
      const touchX = e.touches[0].clientX;
      const deltaX = touchX - touchLastX;
      touchLastX = touchX;

      const touchStrength = Math.abs(deltaX) * 2;
      targetDistortionFactor = Math.min(1.0, targetDistortionFactor + touchStrength);
      targetPosition -= deltaX * settings.touchSensitivity * 2.5;

      // タッチ中はフィルターを最小値で表示
      const filter = document.querySelector('.img__filter') as HTMLElement;
      filter?.classList.add('visible');
      if (filter) {
        filter.style.opacity = '0.3';
      }
    },
    { passive: false }
  );

  window.addEventListener('touchend', () => {
    const velocity = (touchLastX - touchStartX) * 0.0125;
    if (Math.abs(velocity) > 0.3) {
      targetDistortionFactor = Math.min(
        1.0,
        Math.abs(velocity) * 12.5 * settings.distortionSensitivity
      );

      // フィルター効果を速度に基づいて設定
      const filter = document.querySelector('.img__filter') as HTMLElement;
      if (filter) {
        filter.classList.add('visible');
        const initialOpacity = Math.min(1.0, Math.max(0.3, Math.abs(velocity)));
        filter.style.opacity = initialOpacity.toString();

        // 速度に基づいて減衰時間を設定（速いほど長く表示）
        const decayDuration = Math.min(2000, Math.max(800, Math.abs(velocity) * 1500));

        // フィルターの不透明度を徐々に減少
        let startTime = performance.now();
        const animate = () => {
          const currentTime = performance.now();
          const elapsed = currentTime - startTime;
          const progress = elapsed / decayDuration;

          if (progress < 1) {
            const currentOpacity = initialOpacity * (1 - progress);
            filter.style.opacity = Math.max(0, currentOpacity).toString();
            requestAnimationFrame(animate);
          } else {
            filter.style.opacity = '0';
            filter.classList.remove('visible');
          }
        };

        requestAnimationFrame(animate);
      }
    }
    endUserInteraction();
  });

  // 画像ごとのテキスト情報を定義
  const imageDescriptions: { [key: number]: string } = {
    1: '01 / 250324 / GEN IZAWA',
    2: '02 / 250324 / GEN IZAWA',
    3: '03 / 250324 / GEN IZAWA',
    4: '04 / 250324 / GEN IZAWA',
    5: '05 / 250324 / GEN IZAWA',
    6: '06 / 250324 / GEN IZAWA',
    7: '07 / 250203 / SEVESKIG',
    8: '08 / 250203 / SEVESKIG',
    9: '09 / 250203 / SEVESKIG',
    10: '10 / 250203 / SEVESKIG',
    11: '11 / 250203 / SEVESKIG',
    12: '12 / 250203 / SEVESKIG',
    13: '13 / 250203 / SEVESKIG',
    14: '14 / 250203 / SEVESKIG',
    15: '15 / 250203 / SEVESKIG',
    16: '16 / 2501015 / jisetsu',
    17: '17 / 251015 / jisetsu',
    18: '18 / 251015 / jisetsu',
    19: '19 / 251015 / jisetsu',
    20: '20 / 251015 / jisetsu',
    21: '21 / 251015 / jisetsu',
    22: '22 / 251015 / jisetsu',
    23: '23 / 251015 / jisetsu',
    24: '24 / 251015 / jisetsu',
  };

  const imgNameElement = document.querySelector('.img__name');
  let currentCenterImageIndex = 0;

  // 中央の画像インデックスを更新
  const updateCenterImageIndex = () => {
    if (!imgNameElement) return;

    const centerX = 0;
    let closestDistance = Infinity;
    let closestIndex = 0;
    let closestGroupIndex = 1;

    Object.entries(slidesGroups).forEach(([groupKey, slides], groupIdx) => {
      slides.forEach((slide, index) => {
        const distance = Math.abs(slide.position.x);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestIndex = index;
          closestGroupIndex = groupIdx + 1;
        }
      });
    });

    const actualImageIndex = closestIndex + 1 + (closestGroupIndex - 1) * 8;
    if (currentCenterImageIndex !== actualImageIndex) {
      currentCenterImageIndex = actualImageIndex;
      const description = imageDescriptions[actualImageIndex] || `Image ${actualImageIndex}`;
      imgNameElement.textContent = description;
    }
  };

  // アイドル状態の管理関数
  const startIdleTimer = (): void => {
    if (idleTimer) clearTimeout(idleTimer);
    idleTimer = setTimeout(() => {
      isIdle = true;
      showIdleEffects();
    }, IDLE_TIMEOUT);
  };

  const resetIdleTimer = (): void => {
    if (isIdle) {
      hideIdleEffects();
    }
    isIdle = false;
    startIdleTimer();
  };

  const showIdleEffects = (): void => {
    if (!idleMessageElement || !currentTimeElement) return;

    idleMessageElement.style.display = 'block';
    setTimeout(() => {
      idleMessageElement.classList.add('visible');
    }, 0);

    updateCurrentTime();
    const timeInterval = setInterval(updateCurrentTime, 1000);
    idleMessageElement.dataset.timeInterval = timeInterval.toString();
  };

  const hideIdleEffects = (): void => {
    if (!idleMessageElement) return;

    idleMessageElement.classList.remove('visible');
    setTimeout(() => {
      idleMessageElement.style.display = 'none';
    }, 500);

    const timeInterval = parseInt(idleMessageElement.dataset.timeInterval || '0');
    if (timeInterval) clearInterval(timeInterval);
  };

  const updateCurrentTime = (): void => {
    if (!currentTimeElement) return;
    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const seconds = now.getSeconds().toString().padStart(2, '0');
    currentTimeElement.textContent = `${hours}:${minutes}:${seconds}`;
  };

  // イベントリスナーの追加
  const userInteractionEvents = ['mousemove', 'mousedown', 'keydown', 'wheel', 'touchstart'];
  userInteractionEvents.forEach(eventName => {
    window.addEventListener(eventName, resetIdleTimer);
  });

  // 初期タイマーの開始
  startIdleTimer();

  // アニメーションを開始
  animate(performance.now());
  startAutoSlide();
</script>
