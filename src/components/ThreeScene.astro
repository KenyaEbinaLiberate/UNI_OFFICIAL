---
import { settings, calculateSlideSize } from '../utils/three/config';
import type { SlideInterface, ExtendedWindow } from '../utils/three/types';
---

<canvas id="canvas"></canvas>
<div class="img__name"></div>
<div class="idle-message" style="display: none;">
  <div class="message-text">
    <figure><img src="/images/idle_message.svg" alt="logo" /></figure>
  </div>
  <div class="current-time"></div>
</div>

<style>
  canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100dvh;
    opacity: 0;
    visibility: hidden;
    transform: translateX(100px);
    transition:
      opacity 1.5s ease-out,
      transform 1.5s ease-out,
      visibility 0s linear 0s;
  }

  canvas.visible {
    opacity: 1;
    visibility: visible;
    transform: translateX(0);
  }

  @media (min-width: 768px) {
    canvas {
      width: auto;
      height: 100vh;
      aspect-ratio: 9/16;
      margin: 0 auto;
    }
  }

  .img__name.visible {
    opacity: 1;
    visibility: visible;
  }
</style>

<script>
  import * as THREE from 'three';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
  import { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass.js';
  import { settings, calculateSlideSize } from '../utils/three/config';
  import type { SlideInterface, ExtendedWindow } from '../utils/three/types';

  declare const window: ExtendedWindow;

  const canvas = document.getElementById('canvas') as HTMLCanvasElement;
  if (!canvas) throw new Error('Canvas element not found');

  const idleMessageElement = document.querySelector('.idle-message') as HTMLElement;
  const currentTimeElement = document.querySelector('.current-time') as HTMLElement;

  // アイドル状態の管理
  let idleTimer: ReturnType<typeof setTimeout> | null = null;
  let isIdle = false;
  const IDLE_TIMEOUT = 10000; // 10秒

  const renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: true,
    preserveDrawingBuffer: true,
  });

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xe3e3db);

  // カメラの初期化を先に行う
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.z = 5;

  // レスポンシブ対応の関数
  const updateRendererSize = () => {
    // キャンバスは常に画面いっぱいに
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  };

  // 初期設定
  updateRendererSize();
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  // リサイズイベントの設定
  window.addEventListener('resize', () => {
    updateRendererSize();
    // スライドのサイズも更新
    slideSize = calculateSlideSize(camera);
    updateSlidesSize();
  });

  // フェードインアニメーション設定
  setTimeout(() => {
    if (canvas) {
      canvas.classList.add('visible');
      imgNameElement?.classList.add('visible');
    }
  }, 2800); // フェードイン開始までの遅延時間（2.8秒）

  let slideSize = calculateSlideSize(camera);
  const gap = 0; // ギャップを0に設定
  const slideCount = 20;
  const imagesCount = 20;
  const totalWidth = slideCount * slideSize.width;
  const slideUnit = slideSize.width;

  const slides: SlideInterface[] = [];
  let currentPosition = 0;
  let targetPosition = 0;
  let isScrolling = false;
  let autoScrollSpeed = 0;
  let lastTime = 0;
  let touchStartX = 0;
  let touchLastX = 0;
  let prevPosition = 0;

  let currentDistortionFactor = 0;
  let targetDistortionFactor = 0;
  let peakVelocity = 0;
  let velocityHistory = [0, 0, 0, 0, 0];

  let isUserInteracting = false;
  let lastInteractionTime = 0;

  const correctImageColor = (texture: THREE.Texture): THREE.Texture => {
    texture.colorSpace = THREE.SRGBColorSpace;
    return texture;
  };

  const createSlide = (index: number): void => {
    const geometry = new THREE.PlaneGeometry(slideSize.width, slideSize.height, 32, 16);
    const material = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      side: THREE.DoubleSide,
    });

    const mesh = new THREE.Mesh(geometry, material) as unknown as SlideInterface;
    mesh.userData = {
      originalVertices: [...geometry.attributes.position.array],
      targetX: 0,
      currentX: 0,
      index,
    };
    mesh.position.x = index * (slideSize.width + slideSize.gap);

    const imageIndex = (index % imagesCount) + 1;
    const imagePath = `/img${imageIndex}.jpg`;

    new THREE.TextureLoader().load(
      imagePath,
      texture => {
        correctImageColor(texture);
        material.map = texture;
        material.needsUpdate = true;

        // オブジェクトフィットの実装を調整
        const imgAspect = texture.image.width / texture.image.height;
        const slideAspect = slideSize.width / slideSize.height;

        texture.repeat.set(1, 1);
        texture.offset.set(0, 0);

        if (imgAspect > slideAspect) {
          // 画像が横長の場合、幅に合わせる
          texture.repeat.set(1, 1);
          texture.offset.y = (1 - slideAspect / imgAspect) / 2;
        } else {
          // 画像が縦長の場合、高さに合わせる
          texture.repeat.set(1, 1);
          texture.offset.x = (1 - imgAspect / slideAspect) / 2;
        }
      },
      undefined,
      err => console.warn(`Couldn't load image ${imagePath}`, err)
    );

    scene.add(mesh);
    slides.push(mesh);
  };

  // スライドの作成
  for (let i = 0; i < slideCount; i++) {
    createSlide(i);
  }

  slides.forEach(slide => {
    slide.position.x -= totalWidth / 2;
    slide.userData.targetX = slide.position.x;
    slide.userData.currentX = slide.position.x;
  });

  const updateCurve = (
    mesh: SlideInterface,
    worldPositionX: number,
    distortionFactor: number
  ): void => {
    const distortionCenter = new THREE.Vector2(0, 0);
    const distortionRadius = 2.0;
    const maxCurvature = settings.maxDistortion * distortionFactor;

    const positionAttribute = mesh.geometry.attributes.position;
    const originalVertices = mesh.userData.originalVertices;

    for (let i = 0; i < positionAttribute.count; i++) {
      const x = originalVertices[i * 3];
      const y = originalVertices[i * 3 + 1];

      const vertexWorldPosX = worldPositionX + x;
      const distFromCenter = Math.sqrt(
        Math.pow(vertexWorldPosX - distortionCenter.x, 2) + Math.pow(y - distortionCenter.y, 2)
      );

      const distortionStrength = Math.max(0, 1 - distFromCenter / distortionRadius);
      const curveZ = Math.pow(Math.sin((distortionStrength * Math.PI) / 2), 1.5) * maxCurvature;

      positionAttribute.setZ(i, curveZ);
    }

    positionAttribute.needsUpdate = true;
    mesh.geometry.computeVertexNormals();
  };

  // イベントリスナー
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') {
      targetPosition += slideUnit;
      targetDistortionFactor = Math.min(1.0, targetDistortionFactor + 0.3);
    } else if (e.key === 'ArrowRight') {
      targetPosition -= slideUnit;
      targetDistortionFactor = Math.min(1.0, targetDistortionFactor + 0.3);
    }
  });

  window.addEventListener(
    'wheel',
    e => {
      e.preventDefault();
      const wheelStrength = Math.abs(e.deltaY) * 0.001;
      targetDistortionFactor = Math.min(1.0, targetDistortionFactor + wheelStrength);

      targetPosition -= e.deltaY * settings.wheelSensitivity;
      isScrolling = true;
      autoScrollSpeed = Math.min(Math.abs(e.deltaY) * 0.0005, 0.05) * Math.sign(e.deltaY);

      startUserInteraction();

      // スクロール終了を検知して自動スクロールを再開
      if (window.scrollTimeout) {
        clearTimeout(window.scrollTimeout);
      }
      window.scrollTimeout = setTimeout(() => {
        isScrolling = false;
        endUserInteraction();
      }, 150);
    },
    { passive: false }
  );

  window.addEventListener(
    'touchstart',
    e => {
      touchStartX = e.touches[0].clientY;
      touchLastX = touchStartX;
      isScrolling = false;

      startUserInteraction();
    },
    { passive: false }
  );

  window.addEventListener(
    'touchmove',
    e => {
      e.preventDefault();
      const touchY = e.touches[0].clientY;
      const deltaY = touchY - touchLastX;
      touchLastX = touchY;

      const touchStrength = Math.abs(deltaY) * 0.02;
      targetDistortionFactor = Math.min(1.0, targetDistortionFactor + touchStrength);

      targetPosition += deltaY * settings.touchSensitivity;
      isScrolling = true;
    },
    { passive: false }
  );

  window.addEventListener('touchend', () => {
    const velocity = (touchLastX - touchStartX) * 0.005;
    if (Math.abs(velocity) > 0.3) {
      autoScrollSpeed = velocity * settings.momentumMultiplier * 0.05;
      targetDistortionFactor = Math.min(
        1.0,
        Math.abs(velocity) * 2.5 * settings.distortionSensitivity
      );
      isScrolling = true;
      setTimeout(() => {
        isScrolling = false;
      }, 5000);
    }

    endUserInteraction();
  });

  // スライドのサイズを更新する関数
  const updateSlidesSize = () => {
    const newSize = calculateSlideSize(camera);
    slides.forEach((slide, index) => {
      const newGeometry = new THREE.PlaneGeometry(newSize.width, newSize.height, 32, 16);
      slide.geometry.dispose();
      slide.geometry = newGeometry;
      slide.userData.originalVertices = [...newGeometry.attributes.position.array];

      // 位置を更新
      const newTotalWidth = slideCount * newSize.width;
      slide.position.x = index * newSize.width - newTotalWidth / 2 + currentPosition;
      slide.userData.targetX = slide.position.x - currentPosition;
      slide.userData.currentX = slide.position.x;

      // テクスチャの調整（もし存在すれば）
      if (slide.material.map) {
        const texture = slide.material.map;
        const imgAspect = texture.image.width / texture.image.height;
        const slideAspect = newSize.width / newSize.height;

        if (imgAspect > slideAspect) {
          // 画像が横長の場合、高さに合わせる
          const scale = slideAspect / imgAspect;
          texture.repeat.set(1, scale);
          texture.offset.y = (1 - scale) / 2;
        } else {
          // 画像が縦長の場合、幅に合わせる
          const scale = imgAspect / slideAspect;
          texture.repeat.set(scale, 1);
          texture.offset.x = (1 - scale) / 2;
        }
      }
    });
  };

  // イージング関数の追加
  const easeOutExpo = (x: number): number => {
    return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
  };

  // 3. 初期スライドアニメーションの設定
  const initialAnimation = {
    startDelay: 2500,
    duration: 2000,
    targetScroll: -slideUnit * 3,
    started: false,
    startTime: 0,
    autoScrollDelay: 500,
    autoScrollDuration: 1000,
  };

  // 初期アニメーション後に自動スクロールを開始するための変数
  let autoScrollStarted = false;

  // 4. 初期アニメーション開始のトリガー
  setTimeout(() => {
    initialAnimation.started = true;
    initialAnimation.startTime = performance.now();
    targetDistortionFactor = 0.5; // 初期歪み効果の強さ
  }, initialAnimation.startDelay);

  const imgNameElement = document.querySelector('.img__name');
  let currentCenterImageIndex = 0;

  // 画像ごとのテキスト情報を定義
  const imageDescriptions: { [key: number]: string } = {
    1: '01 / 250324 / GEN IZAWA',
    2: '02 / 250324 / GEN IZAWA',
    3: '03 / 250324 / GEN IZAWA',
    4: '04 / 250324 / GEN IZAWA',
    5: '05 / 250324 / GEN IZAWA',
    6: '06 / 250324 / GEN IZAWA',
    7: '07 / 250203 / SEVESKIG',
    8: '08 / 250203 / SEVESKIG',
    9: '09 / 250203 / SEVESKIG',
    10: '10 / 250203 / SEVESKIG',
    11: '11 / 250203 / SEVESKIG',
    12: '12 / 250203 / SEVESKIG',
    13: '13 / 250203 / SEVESKIG',
    14: '14 / 250203 / SEVESKIG',
    15: '15 / 250203 / SEVESKIG',
    16: '16 / 2501015 / jisetsu',
    17: '17 / 251015 / jisetsu',
    18: '18 / 251015 / jisetsu',
    19: '19 / 251015 / jisetsu',
    20: '20 / 251015 / jisetsu',
  };

  // updateCenterImageIndex関数を更新
  const updateCenterImageIndex = () => {
    if (!imgNameElement) return;

    const centerX = 0; // カメラの中心位置
    let closestDistance = Infinity;
    let closestIndex = 0;

    slides.forEach((slide, index) => {
      const distance = Math.abs(slide.position.x);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestIndex = index;
      }
    });

    const actualImageIndex = (closestIndex % imagesCount) + 1;
    if (currentCenterImageIndex !== actualImageIndex) {
      currentCenterImageIndex = actualImageIndex;
      const description = imageDescriptions[actualImageIndex] || `Image ${actualImageIndex}`;
      imgNameElement.textContent = description;
    }
  };

  // ポストプロセッシングの設定
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  const glitchPass = new GlitchPass();
  glitchPass.enabled = false;
  composer.addPass(glitchPass);

  const animate = (time: number): void => {
    requestAnimationFrame(animate);

    // 初期アニメーションの処理
    if (initialAnimation.started) {
      const elapsed = time - initialAnimation.startTime;
      if (elapsed <= initialAnimation.duration) {
        const progress = elapsed / initialAnimation.duration;
        const eased = easeOutExpo(progress);
        targetPosition = initialAnimation.targetScroll * eased;
      } else if (
        !autoScrollStarted &&
        elapsed > initialAnimation.duration + initialAnimation.autoScrollDelay
      ) {
        // 初期アニメーション完了から500ms後に自動スクロール開始
        autoScrollStarted = true;
      }
    }

    const deltaTime = lastTime ? (time - lastTime) / 1000 : 0.016;
    lastTime = time;

    const prevPos = currentPosition;
    currentPosition = THREE.MathUtils.lerp(currentPosition, targetPosition, settings.smoothing);

    const velocity = (currentPosition - prevPos) / deltaTime;
    velocityHistory.shift();
    velocityHistory.push(Math.abs(velocity));

    const avgVelocity = velocityHistory.reduce((sum, val) => sum + val, 0) / velocityHistory.length;

    if (avgVelocity > peakVelocity) {
      peakVelocity = avgVelocity;
    } else {
      peakVelocity *= 0.95;
    }

    targetDistortionFactor *= settings.distortionDecay;
    currentDistortionFactor = THREE.MathUtils.lerp(
      currentDistortionFactor,
      targetDistortionFactor,
      settings.distortionSmoothing
    );

    slides.forEach(slide => {
      const targetX = slide.userData.targetX + currentPosition;
      slide.userData.currentX = THREE.MathUtils.lerp(
        slide.userData.currentX,
        targetX,
        settings.slideLerp
      );
      slide.position.x = slide.userData.currentX;

      updateCurve(slide, slide.position.x, currentDistortionFactor);

      if (slide.position.x < -totalWidth / 2) {
        slide.position.x += totalWidth;
        slide.userData.targetX += totalWidth;
        slide.userData.currentX += totalWidth;
      } else if (slide.position.x > totalWidth / 2) {
        slide.position.x -= totalWidth;
        slide.userData.targetX -= totalWidth;
        slide.userData.currentX -= totalWidth;
      }
    });

    // 自動スクロールの処理を修正
    if (
      autoScrollStarted &&
      !isUserInteracting &&
      time - lastInteractionTime > settings.userInteractionTimeout
    ) {
      targetPosition -= settings.autoScrollSpeed;
    }

    updateCenterImageIndex();

    if (isIdle) {
      scene.background = new THREE.Color(0xe3e3db);
    } else {
      scene.background = new THREE.Color(0xe3e3db);
    }

    composer.render();
  };

  animate(performance.now());

  // イベントリスナーを更新
  const startUserInteraction = () => {
    isUserInteracting = true;
    lastInteractionTime = performance.now();
  };

  const endUserInteraction = () => {
    isUserInteracting = false;
  };

  // アイドル状態の管理関数
  const startIdleTimer = (): void => {
    if (idleTimer) clearTimeout(idleTimer);
    idleTimer = setTimeout(() => {
      isIdle = true;
      showIdleEffects();
    }, IDLE_TIMEOUT);
  };

  const resetIdleTimer = (): void => {
    if (isIdle) {
      hideIdleEffects();
    }
    isIdle = false;
    startIdleTimer();
  };

  const showIdleEffects = (): void => {
    if (!idleMessageElement || !currentTimeElement) return;

    idleMessageElement.style.display = 'block';
    setTimeout(() => {
      idleMessageElement.classList.add('visible');
    }, 0);

    updateCurrentTime();
    // 時刻更新を1秒ごとに行う
    const timeInterval = setInterval(updateCurrentTime, 1000);
    idleMessageElement.dataset.timeInterval = timeInterval.toString();
  };

  const hideIdleEffects = (): void => {
    if (!idleMessageElement) return;

    idleMessageElement.classList.remove('visible');
    setTimeout(() => {
      idleMessageElement.style.display = 'none';
    }, 500);

    // 時刻更新のインターバルをクリア
    const timeInterval = parseInt(idleMessageElement.dataset.timeInterval || '0');
    if (timeInterval) clearInterval(timeInterval);
  };

  const updateCurrentTime = (): void => {
    if (!currentTimeElement) return;
    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const seconds = now.getSeconds().toString().padStart(2, '0');
    currentTimeElement.textContent = `${hours}:${minutes}:${seconds}`;
  };

  // イベントリスナーの追加
  const userInteractionEvents = ['mousemove', 'mousedown', 'keydown', 'wheel', 'touchstart'];
  userInteractionEvents.forEach(eventName => {
    window.addEventListener(eventName, resetIdleTimer);
  });

  // 初期タイマーの開始
  startIdleTimer();
</script>
