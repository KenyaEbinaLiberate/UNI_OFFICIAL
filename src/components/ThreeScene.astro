---
---

<canvas id="canvas"></canvas>

<script>
  import * as THREE from 'three';

  const canvas = document.getElementById("canvas");
  const renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: true,
    preserveDrawingBuffer: true,
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xe3e3db);

  // カメラの視野角を広げて、より画面いっぱいに表示
  const camera = new THREE.PerspectiveCamera(
    45, // より自然な視野角
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.z = 5; // カメラを後ろに下げる

  // 1. キャンバスの初期表示設定
  renderer.domElement.style.opacity = '0';
  renderer.domElement.style.transform = 'translateX(100px)';
  renderer.domElement.style.transition = 'opacity 0.8s ease-out, transform 0.8s ease-out';

  // 2. フェードインアニメーション設定
  setTimeout(() => {
    renderer.domElement.style.opacity = '1';
    renderer.domElement.style.transform = 'translateX(0)';
  }, 2800);  // フェードイン開始までの遅延時間（2.5秒）

  const settings = {
    wheelSensitivity: 0.01,
    touchSensitivity: 0.015,
    momentumMultiplier: 1.5,
    smoothing: 0.15,
    slideLerp: 0.075,
    distortionDecay: 0.95,
    maxDistortion: 2.5,
    distortionSensitivity: 0.12,
    distortionSmoothing: 0.075,
    autoScrollSpeed: 0.001, // 自動スクロールの速度（調整可能）
    userInteractionTimeout: 500, // ユーザー操作後、自動スクロールを再開するまでの時間（ミリ秒）
  };

  // スライドのサイズを画面サイズに基づいて計算
  const calculateSlideSize = () => {
    const viewportHeight = 2 * Math.tan((camera.fov * Math.PI / 180) / 2) * camera.position.z;
    const viewportWidth = viewportHeight * (window.innerWidth / window.innerHeight);
    return {
      width: viewportWidth,     // 100%に変更
      height: viewportHeight    // 100%に変更
    };
  };

  let slideSize = calculateSlideSize();
  const gap = 0;  // ギャップを0に設定
  const slideCount = 10;
  const imagesCount = 12;
  const totalWidth = slideCount * slideSize.width;
  const slideUnit = slideSize.width;

  const slides = [];
  let currentPosition = 0;
  let targetPosition = 0;
  let isScrolling = false;
  let autoScrollSpeed = 0;
  let lastTime = 0;
  let touchStartX = 0;
  let touchLastX = 0;
  let prevPosition = 0;

  let currentDistortionFactor = 0;
  let targetDistortionFactor = 0;
  let peakVelocity = 0;
  let velocityHistory = [0, 0, 0, 0, 0];

  let isUserInteracting = false;
  let lastInteractionTime = 0;

  const correctImageColor = (texture) => {
    texture.colorSpace = THREE.SRGBColorSpace;
    return texture;
  };

  const createSlide = (index) => {
    const geometry = new THREE.PlaneGeometry(slideSize.width, slideSize.height, 32, 16);

    const material = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      side: THREE.DoubleSide,
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = index * slideSize.width; // ギャップを除外
    mesh.userData = {
      originalVertices: [...geometry.attributes.position.array],
      index,
    };

    const imageIndex = (index % imagesCount) + 1;
    const imagePath = `/img${imageIndex}.jpg`;

    new THREE.TextureLoader().load(
      imagePath,
      (texture) => {
        correctImageColor(texture);
        material.map = texture;
        material.needsUpdate = true;

        // オブジェクトフィットの実装を調整
        const imgAspect = texture.image.width / texture.image.height;
        const slideAspect = slideSize.width / slideSize.height;

        texture.repeat.set(1, 1);
        texture.offset.set(0, 0);

        if (imgAspect > slideAspect) {
          // 画像が横長の場合、幅に合わせる
          texture.repeat.set(1, 1);
          texture.offset.y = (1 - slideAspect/imgAspect) / 2;
        } else {
          // 画像が縦長の場合、高さに合わせる
          texture.repeat.set(1, 1);
          texture.offset.x = (1 - imgAspect/slideAspect) / 2;
        }
      },
      undefined,
      (err) => console.warn(`Couldn't load image ${imagePath}`, err)
    );

    scene.add(mesh);
    slides.push(mesh);
  };

  // スライドの作成
  for (let i = 0; i < slideCount; i++) {
    createSlide(i);
  }

  slides.forEach((slide) => {
    slide.position.x -= totalWidth / 2;
    slide.userData.targetX = slide.position.x;
    slide.userData.currentX = slide.position.x;
  });

  const updateCurve = (mesh, worldPositionX, distortionFactor) => {
    const distortionCenter = new THREE.Vector2(0, 0);
    const distortionRadius = 2.0;
    const maxCurvature = settings.maxDistortion * distortionFactor;

    const positionAttribute = mesh.geometry.attributes.position;
    const originalVertices = mesh.userData.originalVertices;

    for (let i = 0; i < positionAttribute.count; i++) {
      const x = originalVertices[i * 3];
      const y = originalVertices[i * 3 + 1];

      const vertexWorldPosX = worldPositionX + x;
      const distFromCenter = Math.sqrt(
        Math.pow(vertexWorldPosX - distortionCenter.x, 2) +
          Math.pow(y - distortionCenter.y, 2)
      );

      const distortionStrength = Math.max(
        0,
        1 - distFromCenter / distortionRadius
      );
      const curveZ =
        Math.pow(Math.sin((distortionStrength * Math.PI) / 2), 1.5) *
        maxCurvature;

      positionAttribute.setZ(i, curveZ);
    }

    positionAttribute.needsUpdate = true;
    mesh.geometry.computeVertexNormals();
  };

  // イベントリスナー
  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft") {
      targetPosition += slideUnit;
      targetDistortionFactor = Math.min(1.0, targetDistortionFactor + 0.3);
    } else if (e.key === "ArrowRight") {
      targetPosition -= slideUnit;
      targetDistortionFactor = Math.min(1.0, targetDistortionFactor + 0.3);
    }
  });

  window.addEventListener(
    "wheel",
    (e) => {
      e.preventDefault();
      const wheelStrength = Math.abs(e.deltaY) * 0.001;
      targetDistortionFactor = Math.min(
        1.0,
        targetDistortionFactor + wheelStrength
      );

      targetPosition -= e.deltaY * settings.wheelSensitivity;
      isScrolling = true;
      autoScrollSpeed =
        Math.min(Math.abs(e.deltaY) * 0.0005, 0.05) * Math.sign(e.deltaY);

      startUserInteraction();

      // スクロール終了を検知して自動スクロールを再開
      clearTimeout(window.scrollTimeout);
      window.scrollTimeout = setTimeout(() => {
        isScrolling = false;
        endUserInteraction();
      }, 150);
    },
    { passive: false }
  );

  window.addEventListener(
    "touchstart",
    (e) => {
      touchStartX = e.touches[0].clientY;
      touchLastX = touchStartX;
      isScrolling = false;

      startUserInteraction();
    },
    { passive: false }
  );

  window.addEventListener(
    "touchmove",
    (e) => {
      e.preventDefault();
      const touchY = e.touches[0].clientY;
      const deltaY = touchY - touchLastX;
      touchLastX = touchY;

      const touchStrength = Math.abs(deltaY) * 0.02;
      targetDistortionFactor = Math.min(
        1.0,
        targetDistortionFactor + touchStrength
      );

      targetPosition += deltaY * settings.touchSensitivity;
      isScrolling = true;
    },
    { passive: false }
  );

  window.addEventListener("touchend", () => {
    const velocity = (touchLastX - touchStartX) * 0.005;
    if (Math.abs(velocity) > 0.3) {
      autoScrollSpeed = velocity * settings.momentumMultiplier * 0.05;
      targetDistortionFactor = Math.min(
        1.0,
        Math.abs(velocity) * 2.5 * settings.distortionSensitivity
      );
      isScrolling = true;
      setTimeout(() => {
        isScrolling = false;
      }, 5000);
    }

    endUserInteraction();
  });

  // リサイズ時の処理を改善
  window.addEventListener("resize", () => {
    // ビューポートのサイズを更新
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    // スライドのサイズを更新
    slideSize = calculateSlideSize();
    slides.forEach((slide, index) => {
      // ジオメトリを更新
      const newGeometry = new THREE.PlaneGeometry(slideSize.width, slideSize.height, 32, 16);
      slide.geometry.dispose();
      slide.geometry = newGeometry;
      slide.userData.originalVertices = [...newGeometry.attributes.position.array];

      // 位置を更新
      const newTotalWidth = slideCount * slideSize.width;
      slide.position.x = (index * slideSize.width) - (newTotalWidth / 2) + currentPosition;
      slide.userData.targetX = slide.position.x - currentPosition;
      slide.userData.currentX = slide.position.x;

      // テクスチャの調整（もし存在すれば）
      if (slide.material.map) {
        const texture = slide.material.map;
        const imgAspect = texture.image.width / texture.image.height;
        const slideAspect = slideSize.width / slideSize.height;

        if (imgAspect > slideAspect) {
          const scale = slideAspect / imgAspect;
          texture.repeat.set(scale, 1);
          texture.offset.x = (1 - scale) / 2;
        } else {
          const scale = imgAspect / slideAspect;
          texture.repeat.set(1, scale);
          texture.offset.y = (1 - scale) / 2;
        }
      }
    });
  });

  // イージング関数の追加
  const easeOutExpo = (x) => {
    return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
  };

  // 3. 初期スライドアニメーションの設定
  const initialAnimation = {
    startDelay: 2800,
    duration: 800,
    targetScroll: -slideUnit * 3,
    started: false,
    startTime: 0,
    autoScrollDelay: 500
  };

  // 初期アニメーション後に自動スクロールを開始するための変数
  let autoScrollStarted = false;

  // 4. 初期アニメーション開始のトリガー
  setTimeout(() => {
    initialAnimation.started = true;
    initialAnimation.startTime = performance.now();
    targetDistortionFactor = 0.5;  // 初期歪み効果の強さ
  }, initialAnimation.startDelay);

  const animate = (time) => {
    requestAnimationFrame(animate);

    // 初期アニメーションの処理
    if (initialAnimation.started) {
      const elapsed = time - initialAnimation.startTime;
      if (elapsed <= initialAnimation.duration) {
        const progress = elapsed / initialAnimation.duration;
        const eased = easeOutExpo(progress);
        targetPosition = initialAnimation.targetScroll * eased;
      } else if (!autoScrollStarted && elapsed > initialAnimation.duration + initialAnimation.autoScrollDelay) {
        // 初期アニメーション完了から500ms後に自動スクロール開始
        autoScrollStarted = true;
      }
    }

    const deltaTime = lastTime ? (time - lastTime) / 1000 : 0.016;
    lastTime = time;

    const prevPos = currentPosition;
    currentPosition = THREE.MathUtils.lerp(
      currentPosition,
      targetPosition,
      settings.smoothing
    );

    const velocity = (currentPosition - prevPos) / deltaTime;
    velocityHistory.shift();
    velocityHistory.push(Math.abs(velocity));

    const avgVelocity =
      velocityHistory.reduce((sum, val) => sum + val, 0) /
      velocityHistory.length;

    if (avgVelocity > peakVelocity) {
      peakVelocity = avgVelocity;
    } else {
      peakVelocity *= 0.95;
    }

    targetDistortionFactor *= settings.distortionDecay;
    currentDistortionFactor = THREE.MathUtils.lerp(
      currentDistortionFactor,
      targetDistortionFactor,
      settings.distortionSmoothing
    );

    slides.forEach((slide) => {
      const targetX = slide.userData.targetX + currentPosition;
      slide.userData.currentX = THREE.MathUtils.lerp(
        slide.userData.currentX,
        targetX,
        settings.slideLerp
      );
      slide.position.x = slide.userData.currentX;

      updateCurve(slide, slide.position.x, currentDistortionFactor);

      if (slide.position.x < -totalWidth / 2) {
        slide.position.x += totalWidth;
        slide.userData.targetX += totalWidth;
        slide.userData.currentX += totalWidth;
      } else if (slide.position.x > totalWidth / 2) {
        slide.position.x -= totalWidth;
        slide.userData.targetX -= totalWidth;
        slide.userData.currentX -= totalWidth;
      }
    });

    // 自動スクロールの処理を修正
    if (autoScrollStarted && !isUserInteracting && time - lastInteractionTime > settings.userInteractionTimeout) {
      targetPosition -= settings.autoScrollSpeed;
    }

    renderer.render(scene, camera);
  };

  animate(performance.now());

  // イベントリスナーを更新
  const startUserInteraction = () => {
    isUserInteracting = true;
    lastInteractionTime = performance.now();
  };

  const endUserInteraction = () => {
    isUserInteracting = false;
  };
</script>

<style>
  canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100dvh;
    z-index: 1;
    opacity: 0;
    transform: translateX(100px);
    will-change: opacity, transform;
  }
</style>
