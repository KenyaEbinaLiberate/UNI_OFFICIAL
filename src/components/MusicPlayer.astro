<div class="player-container">
  <canvas id="visualizer"></canvas>
  <button id="musicPlayer" aria-label="音楽を再生/停止">
    <span class="play-icon">▶</span>
    <span class="pause-icon" style="display: none;">⏸</span>
  </button>
</div>

<script>
  // Web Audio APIのセットアップ
  let audioContext: AudioContext;
  let source: MediaElementAudioSourceNode;
  let analyser: AnalyserNode;
  let audioElements: HTMLAudioElement[] = [];
  let currentTrackIndex = 0;
  let dataArray: Uint8Array;
  let bufferLength: number;

  const initAudio = () => {
    audioContext = new AudioContext();

    // 2つの音声ファイルを設定
    audioElements = [
      new Audio('/sound.mp3'),
      new Audio('/sound2.mp3')
    ];

    // 両方の音声ファイルをループしない設定に
    audioElements.forEach(audio => {
      audio.loop = false;
    });

    // 最初の曲のソースを設定
    source = audioContext.createMediaElementSource(audioElements[currentTrackIndex]);
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 512;
    analyser.smoothingTimeConstant = 0.6;
    bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);

    source.connect(analyser);
    analyser.connect(audioContext.destination);

    // 曲が終わったら次の曲を再生
    audioElements.forEach((audio, index) => {
      audio.addEventListener('ended', () => {
        if (isPlaying) {
          currentTrackIndex = (index + 1) % audioElements.length;

          // 前の曲のソースを切断
          source.disconnect();

          // 新しい曲のソースを設定
          source = audioContext.createMediaElementSource(audioElements[currentTrackIndex]);
          source.connect(analyser);

          // 新しい曲を再生
          audioElements[currentTrackIndex].play();
        }
      });
    });
  };

  let isPlaying = false;
  let animationId: number;

  const player = document.getElementById('musicPlayer') as HTMLButtonElement;
  const playIcon = player?.querySelector('.play-icon') as HTMLElement;
  const pauseIcon = player?.querySelector('.pause-icon') as HTMLElement;

  // キャンバスのセットアップ
  const canvas = document.getElementById('visualizer') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;

  // キャンバスのサイズ設定
  const setCanvasSize = () => {
    const size = 150;
    canvas.width = size;
    canvas.height = size;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
  };

  setCanvasSize();
  window.addEventListener('resize', setCanvasSize);

  // ビジュアライザーの描画
  const drawVisualizer = () => {
    if (!analyser || !dataArray) return;

    analyser.getByteFrequencyData(dataArray);

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const center = canvas.width / 2;
    const radius = 35;

    // 周波数帯域ごとの重み付け
    const bassWeight = 2.0;
    const midWeight = 1.5;
    const highWeight = 1.0;

    // 周波数帯域ごとの平均値を計算
    const getBandAverage = (start: number, end: number) => {
      let sum = 0;
      for (let i = start; i < end && i < bufferLength; i++) {
        sum += dataArray[i];
      }
      return sum / (end - start);
    };

    // 各周波数帯域の平均値
    const bassAvg = getBandAverage(0, 4);
    const midAvg = getBandAverage(4, 12);
    const highAvg = getBandAverage(12, bufferLength);

    // データを8倍に補間
    const interpolatedData: number[] = [];
    for (let i = 0; i < bufferLength; i++) {
      const current = dataArray[i];
      const next = i < bufferLength - 1 ? dataArray[i + 1] : dataArray[i];

      // 現在の値を追加
      interpolatedData.push(current);

      // 7つの補間値を追加
      const step = (next - current) / 8;
      for (let j = 1; j < 8; j++) {
        interpolatedData.push(current + step * j);
      }
    }

    const totalPoints = interpolatedData.length;

    for (let i = 0; i < totalPoints; i++) {
      let weight = highWeight;
      if (i < 32) { // 補間後のインデックスを調整（8倍）
        weight = bassWeight;
      } else if (i < 96) { // 補間後のインデックスを調整（8倍）
        weight = midWeight;
      }

      let bandAvg = highAvg;
      if (i < 32) {
        bandAvg = bassAvg;
      } else if (i < 96) {
        bandAvg = midAvg;
      }

      const amplitude = interpolatedData[i] / 255.0;
      const barHeight = ((amplitude * weight * 50) + (bandAvg * 0.2)) * (isPlaying ? 1 : 0.3);
      const angle = (i * 2 * Math.PI) / totalPoints;

      const startX = center + (radius * Math.cos(angle));
      const startY = center + (radius * Math.sin(angle));
      const endX = center + ((radius + barHeight) * Math.cos(angle));
      const endY = center + ((radius + barHeight) * Math.sin(angle));

      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);

      const hue = (i / totalPoints) * 360;
      ctx.strokeStyle = isPlaying
        ? `hsla(${hue}, 80%, 60%, ${amplitude * 0.8 + 0.2})`
        : `rgba(255, 255, 255, 0.3)`;
      ctx.lineWidth = 1.5; // 線を少し細くして密度感を出す
      ctx.stroke();
    }

    animationId = requestAnimationFrame(drawVisualizer);
  };

  // UIの更新
  const updatePlayerUI = () => {
    if (isPlaying) {
      playIcon.style.display = 'none';
      pauseIcon.style.display = 'block';
    } else {
      playIcon.style.display = 'block';
      pauseIcon.style.display = 'none';
    }
  };

  // カスタムイベントの発行
  const dispatchStateChange = (playing: boolean) => {
    window.dispatchEvent(
      new CustomEvent('audioplayerstatechange', {
        detail: {
          isPlaying: playing,
          audioElement: audioElements[currentTrackIndex],
          audioContext: audioContext,
          analyser: analyser
        }
      })
    );
  };

  // 再生/停止の切り替え
  player?.addEventListener('click', () => {
    if (!audioContext) {
      initAudio();
    }

    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    isPlaying = !isPlaying;

    if (isPlaying) {
      audioElements[currentTrackIndex].play();
      drawVisualizer();
    } else {
      audioElements[currentTrackIndex].pause();
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    }

    updatePlayerUI();
    dispatchStateChange(isPlaying);
  });
</script>

<style>
  #audioVisualizer {
    position: fixed;
    top: 0;
    left: 0;
    width:300px;
    height: 125dvh;
    z-index:999;
    pointer-events: none;
  }
</style>
